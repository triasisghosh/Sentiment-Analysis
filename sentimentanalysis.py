# -*- coding: utf-8 -*-
"""sentimentAnalysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QsMpwF0ZBh5YDVqadXlNuaTRFd6n_cwC
"""

api_key='NDIcnXVunz0wzCu4ZvUKb4AO3'
api_key_secret='0XcNY4ywnUAmH3QpWKALbujl3OudczGOJ1yw3jpnDLQWyC1E8e'
bearer_token='AAAAAAAAAAAAAAAAAAAAAIGKgwEAAAAAeYit%2BdnXZy72gynw6bzl%2BCE3sAo%3D3NPmNRia2t0lwxNVBg8eCie1ld8lnq707VPmSc6O9pEy8FSkz5'
access_token='1292745742503690245-8AlxqJSTUaLaIViTR9UtYFOGDjgFhL'
access_token_secret='mAy9bc4QfcMGwIpmOhNgPBIUWvmXfXRwsZlVHpTTA4rKB'
client_id='RFA1QXhlc0MzRXJPNzFkQzVqQkQ6MTpjaQ'
client_secret='rfOl7o24QRuT4Jexf9K3pap8xVL9PwRPXI9WNUwztopou1H7pJ'

"""Setting the Constants for fetching the API."""

"""Installing the requirements"""

import tweepy
from textblob import TextBlob
import pandas
from IPython.display import display
import numpy
import re
from transformers import AutoTokenizer, AutoModelForSequenceClassification
from scipy.special import softmax
import matplotlib.pyplot as plt

"""Importing libraries"""

roberta='cardiffnlp/twitter-roberta-base-sentiment'
model=AutoModelForSequenceClassification.from_pretrained(roberta)
tokenizer=AutoTokenizer.from_pretrained(roberta)

"""Initializing an attribute of the Transformer"""

companyName='Abdul Kalam'
startDate='2015-01-01'
n=365

def cleanText(txt):
  txt=re.sub('#'+companyName,companyName,txt)
  txt=re.sub("#+",'',txt)
  txt=re.sub('https?:\/\/S+','',txt)
  txt=re.sub('\n','',txt)
  txt=re.sub('RT[\s]+','',txt)
  txt=re.sub('@+','@user ',txt)
  return txt

"""Function for cleaning the tweets using Regular Expression (Basically a part of preparing the dataset)"""

auth=tweepy.OAuthHandler(api_key,api_key_secret)
auth.set_access_token(access_token,access_token_secret)
api=tweepy.API(auth,wait_on_rate_limit=True)

query=companyName
tweets=tweepy.Cursor(api.search, q=query, language='en', since=startDate, tweet_mode='extended').items(n)
all_tweets=[tweet.full_text for tweet in tweets]
print(len(all_tweets))

responseTable=pandas.DataFrame(all_tweets,columns=['Tweets'])
responseTable['Tweets']=responseTable['Tweets'].apply(cleanText)
display(responseTable)

"""Collecting data using the api methods"""

result={}
for i in range(len(all_tweets)):
  try:
    encoded_tweet=tokenizer(responseTable['Tweets'][i],return_tensors='pt')

    decoded_data=model(**encoded_tweet)

    scores=decoded_data[0][0].detach().numpy()
    scores=softmax(scores)
    pol=scores[2]-scores[0]
    op=''
    if scores[0]>scores[1] and scores[0]>scores[2]:
      op='Negative'
    elif scores[1]>scores[0] and scores[1]>scores[2]:
      op='Neutral'
    elif scores[2]>scores[0] and scores[2]>scores[1]:
      op='Positive'
    scores_dict={
        'Tweet':all_tweets[i],
        'Neg':scores[0],
        'Neu':scores[1],
        'Pos':scores[2],
        'Polarity':pol,
        'Opinion':op
      }
    result[i]=scores_dict
  except RuntimeError:
    print(f"\nSize exceed for {i}th data.")

df=pandas.DataFrame(result).T
display(df)

"""Initializing the dataframe and transposing it since the dictionary is in column major"""

plt.figure(figsize=(8,6))
for i in range(df.shape[0]):
  try:
    plt.scatter(df['Polarity'][i],df['Neg'][i],color='Red')
    plt.scatter(df['Polarity'][i],df['Neu'][i],color='Blue')
    plt.scatter(df['Polarity'][i],df['Pos'][i],color='Green')
  except KeyError:
    continue

plt.title('Sentiment Analysis')
plt.xlabel('Polarity')
plt.ylabel('Scores of different type of response:\nRed=Negative, Blue=Neutral, Green=Positive')
plt.show()

"""Scatter plotting the scores vs polarity graph """

avg_neg=df['Neg'].mean()
avg_neu=df['Neu'].mean()
avg_pos=df['Pos'].mean()
opinions=['Negative','Neutral','Positive']
values=[avg_neg,avg_neu,avg_pos]
plt.bar(opinions, values, color ='brown',width = 0.4)
 
plt.xlabel("Opinions")
plt.ylabel("Values")
plt.title("Opinion Analysis")
plt.show()

"""Plotting the Feedback and no of corresponding tweets as a bar graph"""

def sub(txt):
  return TextBlob(txt).sentiment.subjectivity
def pol(txt):
  return TextBlob(txt).sentiment.polarity

responseTable['Subjectivity']=responseTable['Tweets'].apply(sub)
responseTable['Polarity']=responseTable['Tweets'].apply(pol)

op_list=[]
for i in range(responseTable.shape[0]):
  if responseTable['Polarity'][i]<0:
    op_list.append('Negative')
  elif responseTable['Polarity'][i]==0:
    op_list.append('Neutral')
  elif responseTable['Polarity'][i]>0:
    op_list.append('Positive')

responseTable['Opinion']=op_list
display(responseTable)

"""Preparing the response table and plotting it later"""

plt.figure(figsize=(8,6))
for i in range(responseTable.shape[0]):
  plt.scatter(responseTable['Polarity'][i],responseTable['Subjectivity'][i],color='green')

plt.title('Sentiment Analysis( textblob library')
plt.xlabel('Polarity')
plt.ylabel('Subjectivity')
plt.show()
